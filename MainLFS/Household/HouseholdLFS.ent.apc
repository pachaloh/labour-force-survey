{Application 'HOUSEHOLDLFS' logic file generated by CSPro}
// Definition of Global Variables and Functions
//PROC HOUSEHOLDLFS_FF

PROC GLOBAL

//National Adaptation Variables that are controlled from the National Adaptation Tool (NAT):
	numeric SurveyYear = 2024;
	numeric SurveyMonth = 5;
	numeric SurveyDay = 12;
	numeric SurveyDate;
	string SchAttendance;
	string nav_country = "[MALAWI]";
	alpha(26) alphavar;				   { Alpha working variable used in checking alpha vars }
	alpha(26) alphanew;                { Alpha working variable used in checking alpha vars }
	alpha(62) alphalst; 
	numeric NWAP = 15;
	string worklabel;  
	string nav_edu_levels;
	string nav_study_field; //Default ISCED-F
	string nav_farming_prod = "rice, tea, flowers, rubber, etc.";
	string nav_animal_prod = "sheep, goats, pigs, chicken or cattle";	
	string nav_week_start_day = "Monday";
	string nav_week_end_day = "Sunday";
	string nav_job_type = "Fishing or fish farming";
	string nav_products; //Default ISIC
	string nav_products_eg = "CITRUS FRUITS, VEGETABLES, FRESHWATER FISH, CATTLE, CHICKEN, RICE";
	string nav_tasks; //Default ISCO
	string nav_income_activity_eg = "making things for sale, growing produce for sale, buying and reselling things, provided services for pay, raising animals or catching fish for sale";
	string nav_work_type_eg = "CATTLE FARMER; POLICEMAN; COOK; PRIMARY SCHOOL TEACHER";
	string nav_tasks_duties_eg = "BREED, RAISE AND SELL CATTLE; PATROL THE STREETS; PLAN AND PREPARE MEALS; TEACH CHILDREN HOW TO READ AND WRITE";
	string nav_employee = "employee";
	string nav_main_activity_eg = "POLICE DEPARTMENT - PUBLIC SAFETY; RESTAURANT - PREPARING AND SERVING MEALS; TRANSPORT COMPANY - LONG DISTANCE TRANSPORT OF GOODS";
	string nav_business_type = "limited company or partnership";
	string nav_national_business_register = "National Business Register";
	string nav_accounts_type = "assets, income and expenditures, that is a complete balance sheet";
	string nav_social_contributions_systems = "Pension Fund/Health/Unemployment Insurance";
	numeric nav_week_working_hours = 40; //NOTE: The threshold may be customized to the national context. In all cases it should not be below 30 hours
	string nav_employment_center = "PUBLIC EMPLOYMENT CENTER";
	string nav_animals = "sheep, goats, chicken...";
	string nav_wild_food = "mushrooms, berries, herbs...";
	string nav_hunting = "bush meat...";
	string nav_food_drinks = "flour, dried fish, butter, cheese,...";
	string nav_natural_products = "or other natural products";
	string nav_goods = "mats, baskets, furniture, clothing,..";
	string nav_stateless = "STATELESS";
	string nav_fishing = "Fishing, pond fishing or collecting shellfish";
	string nav_or_fishing = "or fishing";
	string nav_agency = "National Statistics Office";
	string nav_DEM_CONF = "This household has been selected to participate in a government survey about the activities that people do to earn a living. The information that you will provide is confidential and will not be shared, but it will help better understand how people in this area live, the jobs they do. Your participation is voluntary. The survey will take approximately 50 minutes. Before I continue with the survey, I need some information about the members of this household"; 
	numeric nav_DEM_EDF_EDL_threshold = 6;
	string nav_worker = "NOT RELATED"; 
	string nav_main_crops_eg = "cassava, rice, â¦";
	numeric MCV_REGION;
	numeric MCV_DISTRICT;
	numeric MCV_GHDWNO;
	numeric MCV_GHHHNO;
	numeric MCV_GHAREA;
	numeric MCV_GHINTID;
	string MCV_INTERVIEWER_NAME = "Household Interviewer";
	numeric GLO_EMP;  	// Global flag for confirmed employed respondents
	numeric GLO_PROV;  	// Global flag for provisional employed respondents
	numeric GLO_OPF;  	// Global flag for own-use producers of foodstuff
	numeric GLO_MLT;  	// Global flag for persons with work in agriculture and in another sector 
	string CapiText;
// Aternative variables used to recalculate GLO variables when AGF module is removed:
	string AGF_ANY_V="0";
	numeric AGF_MKT_V=0;
	numeric AGF_HIS_V=0;
	numeric AGF_HIR_V=0;
	string AGF_CHK_V="0";
	string get_c_and_or = "";
	
	numeric CapiNumberOfPersons;
	// Set GLO variables based on AGF module (using null(_V) variables - in case the module is excluded from the survey):
	function set_GLO_AGF()
		if (pos("a",AGF_ANY_V)>0 or pos("b",AGF_ANY_V)>0 or pos("c",AGF_ANY_V)>0) and (AGF_MKT_V in 1,2 or AGF_HIS_V in 1,2 or AGF_HIR_V = 1) then
		  GLO_EMP = 1;
		endif;
		
		if GLO_PROV=1 and pos("d",AGF_CHK_V)=0 and AGF_HIR_V = 2 then
		  GLO_EMP = 0;
		endif;
		
		if (GLO_PROV=1 and ((pos("a",AGF_CHK_V)>0 or pos("b",AGF_CHK_V)>0 or pos("c",AGF_CHK_V)>0) and pos("d",AGF_CHK_V)>0)) and (AGF_MKT_V in 1,2 or AGF_HIS_V in 1,2 or AGF_HIR_V = 1) then
		  GLO_MLT = 1;
		endif;
		
		if (GLO_PROV=1 and ((pos("a",AGF_CHK_V)>0 or pos("b",AGF_CHK_V)>0 or pos("c",AGF_CHK_V)>0) and pos("d",AGF_CHK_V)>0)) and (AGF_HIR_V = 2) then
		  GLO_MLT = 2;
		endif;
		
		if (GLO_EMP = 1 and (pos("a",AGF_ANY_V)>0 or pos("b",AGF_ANY_V)>0 or pos("c",AGF_ANY_V)>0)) or
			(((pos("a",AGF_CHK_V)>0 or pos("b",AGF_CHK_V)>0 or pos("c",AGF_CHK_V)>0) and pos("d",AGF_CHK_V)=0) and (AGF_MKT_V in 1,2 or AGF_HIS_V in 1,2 or AGF_HIR_V = 1)) then
			GLO_MLT = 3;
		endif;
		
		if AGF_HIR_V = 2 then
		  GLO_OPF = 1;
		endif;
	end;
	
	
	array string household_summary(20,7);
	
	
	function household_reviews()
		do varying numeric ctr = 1 while  ctr <= totocc(PPNO000)
			household_summary(ctr,1) = edit("99",HMPPNO(ctr));
			household_summary(ctr,2) = DEM_NAME(ctr);
			household_summary(ctr,3) = getlabel(DEM_01,DEM_01(ctr));
			household_summary(ctr,4) = edit("999",DEM_06(ctr));
			
			if DEM_06(ctr) in 15:64 then
				household_summary(ctr,5) = "Yes";
			else
				household_summary(ctr,5) = "No";
			endif;
			
			if DEM_06(ctr) in 5:17 then
				household_summary(ctr,6) = "Yes";
			else
				household_summary(ctr,6) = "No";
			endif;

			if DEM_06(ctr) in 15:64 then
				household_summary(ctr,7) = "Yes";
			else
				household_summary(ctr,7) = "No";
			endif;
			
		enddo;
		
		showarray("Households",household_summary,title("LN","NAME OF MEMBER","SEX","AGE","IND","CHD","TUS"));
	end;

	
	
	
	
	


function ShowHidePopulation()

	do numeric ctr = 1 while ctr <= maxocc(HMPPNO000) and visualvalue(P_KEEP_ROW(ctr)) <> notappl

		numeric showRow = ( visualvalue(P_KEEP_ROW(ctr)) = 1 );
		string populationLabel;

		if showRow then
			populationLabel = DEM_NAME(ctr);
		else
			populationLabel = "<Deleted>";
		endif;

		showocc(HMPPNO000(ctr),showRow);
		showocc(PPNO000(ctr),showRow);
		setocclabel(HMPPNO000(ctr),populationLabel);
		setocclabel(PPNO000(ctr),populationLabel);

	enddo;

end;


// ------------------
// ------------------ GPS
// ------------------
// Rest of GPS implementation is in GPS.apc

function IsCompleteGPSData()

	// All GPS data values exist
	IsCompleteGPSData = 0;
	if HH_LATITUDE <> notappl
		and HH_LONGITUDE <> notappl
		and HH_ALTITUDE <> notappl
		and HH_GPS_ACCURACY <> notappl
		and HH_GPS_SAT <> notappl
		and HH_GPS_READTIME <> notappl then
		IsCompleteGPSData = 1;
	endif;

end;

//end;

function IsDesiredAccuracy(accuracy)

	// GPS accuracy is within defined range
	IsDesiredAccuracy = 0;
	if 0 <= accuracy and accuracy <= gps_desired_accuracy then
		IsDesiredAccuracy = 1;
	endif;

end;


function DeleteGPSData()

	// Delete GPS data
	HH_LATITUDE = notappl;
	HH_LONGITUDE = notappl;
	HH_ALTITUDE = notappl;
	HH_GPS_ACCURACY = notappl;
	HH_GPS_SAT = notappl;
	HH_GPS_READTIME = notappl;

end;


function AssignGPSValues(latitude, longitude, altitude, accuracy, satellites, readtime)

	// Assign result of GPS reading
	AssignGPSValues = 0;
	numeric input = 1;
	if IsCompleteGPSData() then
		if gps(accuracy) > HH_GPS_ACCURACY then
			// Prompt user before replacing GPS data with less accurate GPS data
			input = warning("Previous GPS data (accuracy = %f) will be replaced with less "
				"accurate GPS data (accuracy = %f).", HH_GPS_ACCURACY, accuracy)
				select("Confirm", continue, "Cancel", continue);

		else
			// Prompt user before replacing GPS data
			input = warning("Previous GPS data will be replaced.")
				select("Confirm", continue, "Cancel", continue);
		endif
	endif;

	if input <> 2 then
		HH_LATITUDE = latitude;
		HH_LONGITUDE = longitude;
		HH_ALTITUDE = altitude;
		HH_GPS_ACCURACY = accuracy;
		HH_GPS_SAT = satellites;
		HH_GPS_READTIME = readtime;
		AssignGPSValues = 1;
	endif;

end;


function TakeGPSReading()

	// Use the read command to obtain a GPS reading. Use the reading even if it is not within the
	// desired accuracy range. Assign the GPS data to GPS variables in the dictionary.
	if gps_open then
		numeric result = gps(read, gps_max_time, gps_desired_accuracy);

		if result = 1 then
			// Read was successful
			if AssignGPSValues(gps(latitude), gps(longitude), gps(altitude), gps(accuracy), gps(satellites), gps(readtime)) then
				gps_reading_capi_text = "Take GPS reading?";

			else
				gps_reading_capi_text = "You chose not to update GPS data. Retake GPS reading?";
				reenter;
			endif;

		elseif result = -1 then
			gps_reading_capi_text = "GPS reading cancelled by user. Retake GPS reading?";
			reenter;

		elseif result = 0 then
			gps_reading_capi_text = "GPS reading failed. Retake GPS reading?";
			reenter;
		endif;

	else
		gps_reading_capi_text = "Failed to start GPS. Retake GPS reading?";
		reenter;
	endif;

end;


function PollGPS()

	// Use the readlast command to obtain a GPS reading. Use the reading only if it is with the
	// desired accuracy range. Assign the GPS data to global "polled" variables.
	numeric success = 0;
	GPSOpen();
	if gps_open then
		success = 1;
	endif;

	if success and not gps(readlast) then
		success = 0;
	endif;

	if success and IsDesiredAccuracy(gps(accuracy)) then
		polled_latitude = gps(latitude);
		polled_longitude = gps(longitude);
		polled_altitude = gps(altitude);
		polled_accuracy = gps(accuracy);
		polled_satellites = gps(satellites);
		polled_readtime = gps(readtime);
	endif;

end;


function TryPolledGPSData()

	// Try to use the GPS data in the global "polled" variables. If they are valid and
	// the user accepts them then assign them, otherwise return failure.
	TryPolledGPSData = 0;
	if IsValidPolledGPSData() then
		if IsFreshPolledGPSData() then
			// GPS data has not been assigned or rejected by user
			if IsRecentPolledGPSData() then
				// GPS data is recent
				setStalePolledGPSData();
				if AssignGPSValues(polled_latitude, polled_longitude, polled_altitude, polled_accuracy, polled_satellites, polled_readtime) then
					TryPolledGPSData = 1;
					gps_reading_capi_text = "Take GPS reading?";

				else
					gps_reading_capi_text = "You chose not to update GPS data. Retake GPS reading?";
					reenter;
				endif;
			endif;
		endif;
endif;

end;

function ShowHideEmigration()

	do numeric ctr = 1 while ctr <= maxocc(EMIGRATION_ROSTER) and visualvalue(E_KEEP_ROW(ctr)) <> notappl

		if visualvalue(E_KEEP_ROW(ctr)) = 1 then
			showocc(EMIGRATION_ROSTER(ctr));
			setocclabel(EMIGRATION_ROSTER(ctr),XE01(ctr));
		else
			hideocc(EMIGRATION_ROSTER(ctr));
			setocclabel(EMIGRATION_ROSTER(ctr),"<Deleted>");
		endif;

	enddo;
end;
// Variables used in the question text
	string last_4weeks_start_date; 
	string last_week_end_date;
	string nav_week_end_day_yesterday;
	string nav_job_type_short;
	numeric age_proxy = 0;
	numeric OPF_HFOOD_LEN;
	string FOOD_STRING;

// Functions to (re)set variables for interviewee name/proxy and sex:
	// (Re)set Sex variables:
	function string get_his_her()
		if DEM_01(curocc()) = 1 then
		 	get_his_her = "his";
		else get_his_her = "her";
		endif;
	end;
	
	function string get_him_herself()
		if DEM_01(curocc()) = 1 then
		 	get_him_herself = toupper("himself");
		else get_him_herself = toupper("herself");
		endif;
	end;
	
											//	min	max
	array CurrentAttendAgeByHighestLevel(5,2) =	3	5
												6	16
												14	24
												17	120
												17	120
												;
	
	// Variables to fill question text for business/farm before interview:
	string business_farm;
	string farming_fish_animal_products;
	string farming_animal_rearing_fishing;
	string farming_fishing;
	string are_were;
	string last_12_months;
	numeric interview_date_timestamp;
	
// Arrays for set value set
	array codes(100);
	
	array string stringCodes(100);
	array string labels(100);
	
	array vsCodes(100);
	array string vsLabels(100);

// Set Occurrence Label for each member
	string curInfo;
	string curInfo2;

// Function to require input:
	function NotAllowBlankOtherSpecify(string otherField)
	      if length(strip(otherField)) = 0 then 
	         errmsg("Warning: Enter valid text or select code for DON'T KNOW.");
	         reenter;
	      endif;
	end;

// Function to calculate date for the start of last four weeks:
	function string calcLast4WeekDay(string wDay)
	    numeric dayStatic = 0;
	    numeric daydiff = 0;
	    numeric days = 28; // 4 weeks
	    
	    string weekday = strip(timestring("%A",timestamp()));
	    
	    if wDay = "Monday" then
	   dayStatic = 0;
	elseif wDay = "Tuesday" then
	    dayStatic = 1;
	elseif wDay = "Wednesday" then
	     dayStatic = 2;
	elseif wDay = "Thursday" then
	     dayStatic = 3;
	elseif wDay = "Friday" then
	      dayStatic = 4;
	elseif wDay = "Saturday" then 
	      dayStatic = 5;
	elseif wDay = "Sunday" then 
	      dayStatic = 6;
	endif;
	 
	    if weekday = "Monday" then
	   daydiff = 0 - dayStatic;
	elseif weekday = "Tuesday" then
	    daydiff = 1 - dayStatic;
	elseif weekday = "Wednesday" then
	     daydiff = 2 - dayStatic;
	elseif weekday = "Thursday" then
	     daydiff = 3 - dayStatic;
	elseif weekday = "Friday" then
	      daydiff = 4 - dayStatic;
	elseif weekday = "Saturday" then 
	      daydiff = 5 - dayStatic;
	elseif weekday = "Sunday" then 
	      daydiff = 6 - dayStatic;
	endif;
	
	    calcLast4WeekDay = strip(timestring("%A, %B %e",timestamp() -(days+daydiff)*3600*24));
	    
	end;

// Function to calculate date for the end of last four weeks
	function string calcEndLastWeekDay(string wDay)
	    numeric dayStatic = 0;
	    numeric daydiff = 0;
	    numeric days = 7; //1 week 
	    
	    string weekday = strip(timestring("%A",timestamp()));
	    
	    if wDay = "Monday" then
	   dayStatic = 0;
	elseif wDay = "Tuesday" then
	    dayStatic = 1;
	elseif wDay = "Wednesday" then
	     dayStatic = 2;
	elseif wDay = "Thursday" then
	     dayStatic = 3;
	elseif wDay = "Friday" then
	      dayStatic = 4;
	elseif wDay = "Saturday" then 
	      dayStatic = 5;
	elseif wDay = "Sunday" then 
	      dayStatic = 6;
	endif;
	 
	    if weekday = "Monday" then
	   daydiff = 0 - dayStatic;
	elseif weekday = "Tuesday" then
	    daydiff = 1 - dayStatic;
	elseif weekday = "Wednesday" then
	     daydiff = 2 - dayStatic;
	elseif weekday = "Thursday" then
	     daydiff = 3 - dayStatic;
	elseif weekday = "Friday" then
	      daydiff = 4 - dayStatic;
	elseif weekday = "Saturday" then 
	      daydiff = 5 - dayStatic;
	elseif weekday = "Sunday" then 
	      daydiff = 6 - dayStatic;
	endif;
	
	    calcEndLastWeekDay = strip(timestring("%A, %B %e",timestamp() -(days+daydiff)*3600*24));
	    
	end;
numeric i;
  { clear_labels
  Set value labels for certain questions where the response categories can change }
  function clean_labels();
    do i = 1 while i <= 50 by 1
	  codes(i) = notappl;
	  labels(i) = "";
    enddo;
  end;






PROC DEM_21A


preproc

	ask if DEM_06 >= 5;
PROC DEM_22A
preproc

	ask if DEM_06 >= 5;
PROC HOUSEHOLDLFS_FF


preproc

	SurveyDate = SurveyYear * 10000
			   + SurveyMonth * 100
			   + SurveyDay;

	// setup the userbar, adding a button to view the manual
	userbar(clear);
//	userbar(add button,"View Manual",ViewManual);
	userbar(show);

	// if the interviewer has previously changed the language, start with the last language used
//	setlanguage(loadsetting(LanguageSettingKey));



	// In case we come back from partial save or modify mode, do this after loading the questionnaire




PROC CLUSTER

preproc
	
	// Retreive parameters from menu program via pff file
	if sysparm("CLUSTER") <> "" then
		CLUSTER = tonumber(sysparm("CLUSTER"));
		
		// protect field so the interviewer cannot modify it
		setproperty($, "Protected", "Yes");
	endif;
	
		if HH_START_INTERVIEW_TIME = notappl then
		HH_START_INTERVIEW_TIME = timestamp();
	endif;

	setproperty($, "Protected", "Yes");

PROC REGION
preproc

loadcase(CLUSTERS_DICT,CLUSTER);
	REGION   = CREGION;
	DISTRICT = CDISTRICT;
	//= CTA;
	
	
	
	
PROC DISTRICT

preproc
//setproperty($, "Protected", "Yes");
//$ = 1;

PROC GHHHNO

preproc

	// Retreive parameters from menu program via pff file
	if sysparm("GHHHNO") <> "" then
		GHHHNO = tonumber(sysparm("GHHHNO"));
		
		// protect field so the interviewer cannot modify it
		//setproperty($, "Protected", "Yes");
	endif;

PROC GHUNID


preproc

if $ = "" then
$ = uuid();
endif;

setproperty($, "Protected", "Yes");


PROC HH_GPS_READING

onfocus

	PollGPS();

	if IsCompleteGPSData() then
		// Update value set
		if getos() in 10,20 then
			setvalueset(HH_GPS_READING, HH_GPS_READING_VS2);
		else
			setvalueset(HH_GPS_READING, HH_GPS_READING_VS4);
		endif;

		// Update CAPI Text
		gps_data_status_capi_text = "collected";
		gps_accuracy_status_capi_label = "GPS accuracy: ";
		if IsDesiredAccuracy(HH_GPS_ACCURACY) then
			gps_accuracy_status_capi_text = "good";

		else
			gps_accuracy_status_capi_text = "bad";
		endif;

		// Preselect option to keep data
		$ = 2;

	else
		// Update value set
		if getos() in 10,20 then
			setvalueset(HH_GPS_READING, HH_GPS_READING_VS1);
		else
			setvalueset(HH_GPS_READING, HH_GPS_READING_VS3);
		endif;

		// Update CAPI Text
		gps_data_status_capi_text = "not collected";
		gps_accuracy_status_capi_label = "";
		gps_accuracy_status_capi_text = "";
		
		
	endif;

postproc

	// Handle user input
	if $ = 1 then
		// Collect GPS data
		numeric result = TryPolledGPSData();
		if not result then
			// Polled GPS reading not used
			TakeGPSReading();
		endif;

	elseif $ = 2 then
		// Skip collecting GPS data, but keep GPS data
		gps_reading_capi_text = "Take GPS reading?";

	elseif $ = 3 then
		// Skip collecting GPS data, and delete GPS data
		if IsCompleteGPSData() then
			warning("GPS data will be deleted.")
				select("Confirm", continue, "Cancel", HH_GPS_READING);
		endif;

		DeleteGPSData();
		gps_reading_capi_text = "Take GPS reading?";

	else
		warning("Unhandled value set option.");
		reenter;
	endif;
PROC GHVFDT

preproc

// Do not overwrite the start date if modifying the case
if visualvalue(GHVFDT) = notappl then
GHVFDT = sysdate("YYYYMMDD");
noinput;
endif;

postproc

// Verify the interview start date
if $ > sysdate("YYYYMMDD") then
errmsg("Please enter a valid value! The interview date cannot be in the future.");
reenter;
endif;

// Set the Linux-format interview date
interview_date_timestamp = DateDiff(19700101, GHVFDT, "d")*86400;

// Set week_end_date varaible to "yesterday" when (Today â 1) = week_end_date
if timestring("%A", timestamp() - 86400) = nav_week_end_day and GHVFDT = sysdate("YYYYMMDD") then
last_week_end_date = "yesterday";
nav_week_end_day_yesterday = "yesterday";
else
last_week_end_date ="last " + nav_week_end_day;
nav_week_end_day_yesterday = nav_week_end_day;
endif;


PROC GHAREA

// prefill for testing
preproc
$ = 1;

PROC GHHRPL

// prefill for testing
preproc
$ = 1;


PROC GHHHSIZE


preproc

// Skip entry. It will be calculated based on the DEM_NAME roster

set behavior($) canenter(notappl) on (noconfirm);


postproc

if $ = notappl then
$ = 0;
endif;


PROC GHNELIGIBLE

preproc

// Skip entry. It will be calculated based on the DEM module

set behavior($) canenter(notappl) on (noconfirm);

postproc

if $ = notappl then
$ = 0;
endif;

PROC GHINTID
// prefill for testing
{preproc
$ = "0";
}

PROC GHINTNAME
{
if $="" then
errmsg("This field cannot be blank. Please enter the interviewer name.");
//reenter;
endif;
}
// Capitalise the name of the interviewer
MCV_INTERVIEWER_NAME = toupper(strip($));

// Capitalise the name of the agency
nav_agency = toupper(nav_agency);

//noinput;
PROC DEM_STR

	// Allow to perform the interview only with an adult
	if $=2 then
		errmsg("Please return to the household and resume the interview when an adult member is available.");
		reenter;
	endif;


PROC P_KEEP_ROW

preproc

	// Initialize when entering row for 1st time
	if visualvalue(P_KEEP_ROW) = notappl or curocc() = 1 then
		P_KEEP_ROW = 1;
		noinput;
	endif;

onfocus

	if curocc() = 1 then
		PollGPS();
	endif;
	
	// once a row is deleted, it can't be modified
	if visualvalue(P_KEEP_ROW) = 2 then
		setproperty(P_KEEP_ROW,"Protected","Yes");
	else
		setproperty(P_KEEP_ROW,"Protected","No");
	endif;

postproc

	ShowHidePopulation();

	if P_KEEP_ROW = 2 then // the row is deleted

		if curocc() = 1 then
			errmsg("Cannot delete first row.");
			P_KEEP_ROW = 1;
		else
			skip to P_MORE_ROWS;
		endif;

	endif;


PROC HMPPNO

preproc
	
	$ = curocc();
	
	setproperty($,"protected","yes");
PROC DEM_NAME

preproc

	// Capitalise the name of the interviewer
	MCV_INTERVIEWER_NAME = toupper(MCV_INTERVIEWER_NAME);

	// Capitalise the name of the agency
	nav_agency = toupper(nav_agency);

postproc

	// Validate that field is not blank
	NotAllowBlankOtherSpecify($);

	// Capitalise the name of the interviewee
	DEM_NAME = toupper(strip(DEM_NAME));


PROC P_MORE_ROWS

preproc

	savepartial();
	
	if curocc() = 1 then
		GPSClose();
	endif;

	// if there are already more rows defined, this value has to be 1...
	if curocc() < maxocc(HMPPNO000) and DEM_NAME(curocc() + 1) <> "" then
		P_MORE_ROWS = 1;
		noinput;
	endif;

onfocus

	// and then cannot be modified
	if curocc() < maxocc(HMPPNO000) and DEM_NAME(curocc() + 1) <> "" then
		setproperty(P_MORE_ROWS,"Protected","Yes");
	else
		setproperty(P_MORE_ROWS,"Protected","No");
	endif;

	CapiNumberOfPersons = 0;
	CapiText = "";

	do numeric ctr = 1 while ctr <= curocc()

		if P_KEEP_ROW(ctr) = 1 then
			CapiText = CapiText + maketext("%s, %s<br />",strip(DEM_NAME(ctr)),getlabel(DEM_01,DEM_01(ctr)));
			inc(CapiNumberOfPersons);
		endif;

	enddo;

postproc

	if P_MORE_ROWS = 2 then
		endgroup;
	endif;


PROC HH_RESP_LN

onfocus
	valueset numeric hh_roster;
	
	do varying numeric ctr = 1 while ctr <= totocc(HMPPNO000)
		hh_roster.add(DEM_NAME(ctr),HMPPNO(ctr));
	enddo;
	
	setvalueset(HH_RESP_LN,hh_roster);
{PROC PPNO

onfocus

	// Calculate the total number of members
	GHHHSIZE = totocc(HMPPNO000);
	
	// Calculate the start date of the last four weeks
	//last_4weeks_start_date = calcLast4WeekDay(nav_week_start_day);

}
PROC DEM_REC_FORM



PROC PPNO


preproc

	// Calculate the total number of members
	GHHHSIZE = totocc(HMPPNO000);

	// Calculate the start date of the last four weeks
	//last_4weeks_start_date = calcLast4WeekDay(nav_week_start_day);
	
	$ = curocc();
	
	setproperty($,"protected","yes");
PROC DEM_01
preproc

	savepartial();

	if P_KEEP_ROW = 2 then
		skip to next;
	elseif curocc() > totocc(HMPPNO000) then
		endgroup;
	endif;
PROC DEM_02

onfocus

	if curocc() = 1 then
		PollGPS();
	endif;

	if curocc() = 1 then
		setproperty(DEM_02,"Protected","Yes");
		setvalueset(DEM_02,DEM_02_VS1);
		DEM_02 = 1;

	else
		setproperty(DEM_02,"Protected","No");
		setvalueset(DEM_02,DEM_02_VS2);

	endif;


postproc

	if DEM_02 = 2 then
	
		if DEM_01 = DEM_01(1) then
		
			errmsg("The sex of the spouse and head of household cannot be the same")
				select("Reenter relationship",DEM_02, "Reenter sex",DEM_01);
			
		endif;
	
	endif;
PROC DEM_03
preproc

	savepartial();
PROC DEM_04

preproc

	savepartial();
	
postproc


if DEM_04 = 2 and DEM_03 in 30,31 then
errmsg("Invalid combination")
select("Reenter Month of Birth",DEM_04,
		"Reenter the Day of Birth", DEM_03);
		
elseif DEM_04 in 4,6,9,11 and DEM_03 = 31 then
errmsg("Invalid combination")
select("Reenter Month of Birth",DEM_04,
		"Reenter the Day of Birth", DEM_03);
		
endif;

PROC DEM_05

	//Pachalo, 05Oct2023, Replaced SurveyDate with sysdate("YYYYMMDD")
	if DEM_05 > SurveyYear and DEM_04 > SurveyMonth and DEM_04 <> 99 then
		errmsg("Date of birth %04d/%02d is invalid. Date of birth cannot be after survey reference date of %s.",
			DEM_05, DEM_04, edit("9999/99/99", sysdate("YYYYMMDD")));
		reenter;
	endif;
PROC DEM_06

postproc

	if DEM_05 <> missing then 
	
		numeric birthDate = DEM_05 * 10000 + DEM_04 * 100 + 1;
		numeric calculatedAgeYears = datediff(birthDate, sysdate("YYYYMMDD"), "y");
		
	
		if DEM_04 = SurveyMonth then //if born in survey month
			if not(DEM_06 in calculatedAgeYears - 1:calculatedAgeYears) then
				// If AGE is not in the range of calculated years then it is an error.
				if calculatedAgeYears - 1 < 0 then
					errmsg("Age %d is invalid. The age is %d based on the date of birth %04d/%02d and survey reference date of %s.",
						$, calculatedAgeYears, DEM_05, DEM_04, edit("9999/99/99", sysdate("YYYYMMDD")))
						select("Reenter Month", DEM_04,
				      		   "Reenter Year of Birth", DEM_05,
				       	   	   "Reenter the age", DEM_06);	
				       	   	   			
				else
					errmsg("Age %d is invalid. The age is either %d or %d based on the date of birth %04d/%02d and survey reference date of %s.",
						$, calculatedAgeYears - 1, calculatedAgeYears, DEM_05, DEM_04, edit("9999/99/99", sysdate("YYYYMMDD")))
						select("Reenter Month", DEM_04,
				      		   "Reenter Year of Birth", DEM_05,
				       	   	   "Reenter the age", DEM_06);
				       	   	   
				endif;
			endif;
			
		else		
			if DEM_04 = 99 then //If month born is unknown, then set it to January.
				numeric unknownMonth = 1;
				numeric unknownBirthDate = DEM_05 * 10000 + unknownMonth * 100 + 1;							  		 
				calculatedAgeYears = datediff(unknownBirthDate, sysdate("YYYYMMDD"), "y");
				
				if not(DEM_06 in calculatedAgeYears - 1:calculatedAgeYears) then
					// If Age is not in the range of calculated years then it is an error.
					if calculatedAgeYears - 1 < 0 then
						errmsg("Age %d is invalid. The age is %d based on the year of birth %04d and survey reference date of %s.",
							$, calculatedAgeYears, DEM_05, edit("9999/99/99", sysdate("YYYYMMDD")))
							select("Reenter Month", DEM_04,
					      		   "Reenter Year of Birth", DEM_05,
					       	   	   "Reenter the age", DEM_06);
					       	   	   
					else
						errmsg("Age %d is invalid. The age is either %d or %d based on the year of birth %04d and survey reference date of %s.",
							$, calculatedAgeYears - 1, calculatedAgeYears, DEM_05, edit("9999/99/99", sysdate("YYYYMMDD")))
							select("Reenter Month", DEM_04,
					      		   "Reenter Year of Birth", DEM_05,
					       	   	   "Reenter the age", DEM_06);
					       	   	   
					endif;
				endif;
				
			elseif DEM_06 <> calculatedAgeYears then
				errmsg("Age %d is invalid. The age is %d based on the date of birth %04d/%02d and survey reference date of %s.",
					$, calculatedAgeYears, DEM_05, DEM_04, edit("9999/99/99", sysdate("YYYYMMDD")))
					select("Reenter Month", DEM_04,
			      		   "Reenter Year of Birth", DEM_05,
			       		   "Reenter the age", DEM_06);
			       		   		
			endif;
		endif;
	endif;

	// Age consistency checks on relationship
	if DEM_02 = 1 then // Head
		if DEM_06 < 12 then
			errmsg("Head of household must be at least 12 years old.")
					select("Reenter age", DEM_06, "Reenter name", DEM_NAME(1));
		endif;
		
	elseif DEM_02 =  2 then // Wife or husband
		if DEM_06 < 12 then
			errmsg("Spouse must be at least 12 years old.")
				select("Reenter spouse's age", DEM_06,
					   "Reenter head's age", DEM_06(1));
		endif;
		
	elseif DEM_02 =  3 then // Son or daughter
		if DEM_06 > DEM_06(1) - 12 then
			warning("Child's age(=%d) must be at least 12 years younger than head's age(=%d)", DEM_06, DEM_06(1))
				select("Reenter child's age", DEM_06,
					   "Reenter Head's age", DEM_06(1),
					   "Continue", continue);
		endif;
		
	elseif DEM_02 =  4 then // Son-in-law or daughter-in-law
		if DEM_06 < 12 then
			warning("Child-in-law must be at least 12 years old.")
				select("Reenter child-in-law's age", DEM_06,
					   "Reenter head's age", DEM_06(1),
					   "Continue", continue);
		endif;
	
	elseif DEM_02 =  5 then // Grandchild
		if DEM_06 > DEM_06(1) - 24 then
			warning("Grandchild's age(=%d) must be at least 24 years younger than head's age(=%d)", DEM_06, DEM_06(1))
				select("Reenter grandchild's age", DEM_06,
					   "Reenter head's age", DEM_06(1),
					   "Continue", continue);
		endif;

	elseif DEM_02 =  6 then // Parent
		if DEM_06 < DEM_06(1) + 12 then
			warning("Parent's age(=%d) must be at least 12 years older than head's age(=%d)", DEM_06, DEM_06(1))
				select("Reenter parent's age", DEM_06,
					   "Reenter head's age", DEM_06(1),
					   "Continue", continue);
		endif;
			
	endif;

PROC DEM_07

preproc

	savepartial();
 ask if DEM_06>=12;

postproc

	// Validate marital status matches the reported relationship with head/reference person
	if DEM_02=2 and $ in 1,5,6 then
		errmsg ("Warning:  Marital status does not match with reported relationship to head. Please enter a valid value.");
		reenter;
	endif;


PROC DEM_08


preproc ask if DEM_06 >= 3;
PROC DEM_09


preproc 
	ask if DEM_06>=3;

postproc

	if $ = 1 then // never attended
		skip to DEM_14;

	elseif $ = 2 then
		SchAttendance = "ever attended";

	elseif $  = 3 then
		SchAttendance = "is attending";
	endif;

	{if $ in 2,3 and DEM_08=2 then
	errmsg("Invalid combination")
	select("Reenter Literacy %d",DEM_08,
			"Reenter School %d attendance", $);
			
		endif;
	}
PROC DEM_10

	
preproc ask if DEM_06>=3;

postproc
		numeric HighestLevelPossible;

	//Pachalo: The minimum age for level of school. 
	if DEM_09 = 2 then 				//if has ever attended school
			   recode DEM_06(P_KEEP_ROW)  -> HighestLevelPossible;
			   
						4:10     -> 1 ;								// Primary. Pachalo: You don't expect ages between 4 and 10 in the secondary
						11:19    -> 2 ;		  						// Secondary
								 -> notappl;						// any value is valid

			   endrecode;

	elseif DEM_09 = 3 then 			//if currently attending school
			   recode DEM_06(P_KEEP_ROW)   -> HighestLevelPossible;
						4:10     -> 1 ;							// Primary
						11:17    -> 2 ;		  					// Secondary
								-> notappl;						// any value is valid
			   endrecode;
	endif;

	if $ > HighestLevelPossible then 				//if highest level of sch is higher than expected
		if DEM_09 = 2 then 			//if has ever attended school
			warning("The highest level of school ever attended(%s) seem high for %s's age(%d years)", getlabel($,$), strip(DEM_NAME(curocc())), DEM_06)
				select ("Reenter highest level of school", $,
						"Reenter age", DEM_06(P_KEEP_ROW),
						"Continue", continue);

		elseif DEM_09 = 3 then 		//if currently attending school
			warning("The highest level of school currently being attended (%s) seem high for %s's age(%d years)", getlabel($,$), strip(DEM_NAME(curocc())), DEM_06)
				select ("Reenter highest level of school", $,
						"Reenter age", DEM_06(P_KEEP_ROW),
						"Continue", continue);
		endif;
	else
		if DEM_09 = 3 then

			// index from P18A_HIGHEST_LEVEL (which starts at 0 as preschool) to row in array (which starts at 1)
			numeric arrayIndex = DEM_10 + 1;

			if	DEM_06 < CurrentAttendAgeByHighestLevel(arrayIndex,1) or	// minimum age
				DEM_06 > CurrentAttendAgeByHighestLevel(arrayIndex,2) then	// maximum age

				warning("%s is %d years and attending %s. Is this correct?", strip(DEM_NAME(curocc())), DEM_06, getlabel(DEM_10,DEM_10))
					select ("Reenter Highest level of School", DEM_10,
							"Continue", continue);

			endif;
		endif;
	endif;
PROC DEM_11


preproc

	ask if DEM_10 <> 0 {and DEM_10 <> 3};
	ask if DEM_06>=3;
	
onfocus

	setvalueset($,maketext("DEM_11_VS%d",DEM_10));

postproc

	numeric HighestClassCheck;

	if DEM_10 = 1 then // primary
		recode DEM_06  -> HighestClassCheck;
		 4:5    -> 1;			 // Standard 1
		 6:13   -> DEM_06 - 5 ; // Standard 1 - 8
		 		-> 8;            // 14+ yrs max is still Standard 8
		endrecode;

	elseif DEM_10 = 2 then 	//Secondary

	   recode DEM_06  -> HighestClassCheck;
			14	-> 9	;	// Form1
			15	-> 10	;	// Form2
			16	-> 11	;	// Form3
			17	-> 12	;	// Form4
			18	-> 13	;	// Form5
			19	-> 14	;	// Form6
				-> 14   ;   // 20+ yrs max is Form 6
		endrecode;
{
	elseif DEM_10 = 3 then //University

		recode DEM_06  -> HighestClassCheck;
		   17    -> 15;			// 1st Year
		   18    -> 16 ; 		// 2nd Year
		   19    -> 17 ; 		// 3rd Year
		   20    -> 18 ; 		// 4th Year
		   21    -> 19 ; 		// 5th Year
		   22    -> 20 ; 		// 6th Year
		   23	 -> 21 ;		// Msc
		   24	 -> 22 ;		// Msc
		   25	 -> 23 ;	    // PhD Year1
		   26	 -> 24 ;	    // PhD Year2
		   27	 -> 25 ;	    // PhD Year3
		   28	 -> 26 ;	    // PhD Year4
				 -> 26 ;        // 29+ yrs max is PhD Year 4
		endrecode;
}

	elseif DEM_10 = 4 then //University

		recode DEM_06  -> HighestClassCheck;
		   17    -> 15;			// 1st Year
		   18    -> 16 ; 		// 2nd Year
		   19    -> 17 ; 		// 3rd Year
		   20    -> 18 ; 		// 4th Year
		   21    -> 19 ; 		// 5th Year
		   22    -> 20 ; 		// 6th Year
		   23	 -> 21 ;		// Msc
		   24	 -> 22 ;		// Msc
		   25	 -> 23 ;	    // PhD Year1
		   26	 -> 24 ;	    // PhD Year2
		   27	 -> 25 ;	    // PhD Year3
		   28	 -> 26 ;	    // PhD Year4
				 -> 26 ;        // 29+ yrs max is PhD Year 4
		endrecode;

	elseif DEM_10 = 5 then //other tertiary level

	   recode DEM_06  -> HighestClassCheck;
		17:18    -> 27 ;		// Other tertiary 1st Year
		   19    -> 28 ; 		// Other tertiary 2nd Year
		   20    -> 29 ; 		// Other tertiary 3rd Year
		   21    -> 30 ; 		// Other tertiary 4th Year
				 -> 30 ;        // 22+ yrs max is Other tertiary Year 4
		endrecode;

	endif;

PROC DEM_12

preproc

	savepartial();

	ask if DEM_10 <> 0;
	
	ask if DEM_06>=5;

onfocus

	if DEM_10 = 1 and DEM_11 in 0:5 then
		setvalueset(DEM_12, DEM_12_VS5);
		$=0;
		skip to DEM_14;
	endif;
	
	if DEM_10 = 1 and DEM_11 in 6:8 then
		setvalueset(DEM_12, DEM_12_VS1);
		
	elseif DEM_10 = 2 and DEM_11 in 9:10 then
		setvalueset(DEM_12, DEM_12_VS6);
	
	elseif DEM_10 = 2 and DEM_11 in 11:12 then
		setvalueset(DEM_12, DEM_12_VS2);
		
	elseif DEM_10 = 3 then
		setvalueset(DEM_12, DEM_12_VS10);	
	
	elseif DEM_10 = 4 and DEM_11 in 15:17 then
		setvalueset(DEM_12, DEM_12_VS7);
		
	elseif DEM_10 = 4 and DEM_11 in 18:22 then 
		setvalueset(DEM_12, DEM_12_VS8);
		
	elseif DEM_10 = 4 and DEM_11 in 23:33 then 
		setvalueset(DEM_12, DEM_12_VS9);
	
	elseif DEM_10 = 5 then
		setvalueset(DEM_12, DEM_12_VS8);
	
	endif;

//Pachalo: 2 Oct, 2023
postproc
	
	
PROC DEM_13

preproc ask if DEM_10 in 3,4;

ask if DEM_06>=5;

PROC DEM_13A


preproc ask if DEM_10 in 3,4;

ask if DEM_06>=5;

onfocus

if DEM_10 = 3 and DEM_12 = 10 then
	setvalueset($,DEM_13A_VS3);
elseif DEM_10 = 3 and DEM_12 <> 10 then
	setvalueset($,DEM_13A_VS2);
endif;


PROC DEM_13B

preproc ask if DEM_10 in 3,4 and DEM_13A < 11 ;

ask if DEM_06>=5;

onfocus
		valueset numeric Narrow_field_ed;
		numeric index=1;
			
		forcase NARROW_FIELD_CODES_DICT where DEM_13A = N_BROAD_FIELD_CODES do
			Narrow_field_ed.add(N_NARROW_FIELD, N_NARROW_FIELD_CODES);
		endfor;
		
setvalueset($,Narrow_field_ed);
PROC DEM_13C

preproc ask if DEM_10 in 3,4 and DEM_13A < 11;

ask if DEM_06>=5;

onfocus
		valueset numeric Detailed_field_ed;
		
		forcase DETAILED_FIELD_CODES_DICT where DEM_13B = NARROW_FIELD_CODES do
			Detailed_field_ed.add(DETAILED_FIELD, DETAILED_FIELD_CODES);			
		endfor;
		
setvalueset($,Detailed_field_ed);
PROC DEM_13D

preproc
	
	ask if DEM_10 = 3;
PROC DEM_13E

preproc
	
	ask if DEM_13D = 1;
PROC DEM_13F

preproc
	
	ask if DEM_13D = 2;
PROC DEM_14

	if $ = 1 then
		skip to DEM_19;
	endif;

PROC DEM_16



postproc

	if DEM_16 > SurveyYear then
		errmsg("Year of arrival %04d is invalid. Year of arrival cannot be after survey reference date of %s.",
			DEM_16, edit("9999/99/99", sysdate("YYYYMMDD")));
		reenter;
	endif;
	
	if DEM_16 < DEM_05 then
		errmsg("Year of arrival %04d cnnot be less than year of birth %04d",
			DEM_16, DEM_05);
		reenter;
	endif;

{
postproc
if DEM_YS <> missing then 
	
		numeric calculatedYears = surveyyear - DEM_YOA;
		
		if calculatedYears < 0 then
		errmsg("Year of arrival %d cannot be greater than survey Year Age %d is invalid. The Years spent in Malawi is %d based on the date of Year of Arrival %d",
		DEM_YOA, surveyyear, calculatedYears, DEM_YOA)
		select("Reenter Year arrival", DEM_MONTH_BORN,
			 "Reenter the Years spent in Malawi", DEM_YS);
		 endif;
		 
		 endif;
}
PROC DEM_17

preproc

ask if DEM_16 = missing;
PROC DEM_18

if DEM_06 < 10 and $ in 1,2,3,5 then 

	errmsg("Too young for reason of arrival")
				select("Reenter Reason of Arrival", DEM_18,
					   "Reenter age", DEM_06);
					   //"Continue", continue);
endif;
	
{if DEM_06 in 10:12 and $ =5 then 

	errmsg("Too young for reason of arrival")
				select("Reenter Reason of Arrival", DEM_18,
					   "Reenter age", DEM_06,
					   "Continue", continue);
endif;}
PROC DEM_19

	if (pos("A",$)>0 or pos("B",$)>0) and pos("C",$)>0 then
		errmsg("Stateless can not be combined with other options");
		reenter;
	endif;


	if ((pos("A",$) + pos("B",$) + pos("C",$)) = 0) then
		errmsg("Atleast one option should be selected");
		reenter;
	endif;
PROC DEM_20

preproc

ask if pos("B",DEM_19)>0;

PROC DEM_21

preproc

	ask if DEM_06 >= 5;
	
PROC DEM_22
preproc

	ask if DEM_06 >= 5;

PROC DEM_23
preproc

	ask if DEM_06 >= 5;
PROC DEM_24
preproc

	ask if DEM_06 >= 5;
PROC DEM_25
preproc

	ask if DEM_06 >= 5;
PROC DEM_26
preproc

	ask if DEM_06 >= 8;
PROC DEM_27

if $ = 1 then
	errmsg("Please comfirm if %s is albino",DEM_NAME)
		select("Reenter Albinism",DEM_27,"Continue",Continue);
endif;
PROC TU_ELG_LN

preproc

    if visualvalue($) = notappl then
		
	valueset numeric eligible_for_time_use;
	
	do numeric ctr = 1 while ctr <= totocc(HMPPNO000)
		if DEM_06(ctr) >= NWAP then
			eligible_for_time_use.add(DEM_NAME(ctr),ctr)
		endif;
	enddo;
	
	$ = randomin(eligible_for_time_use);
	
	//errmsg("%v is selected for time use",DEM_NAME($));
	
	noinput;
	
	endif;
PROC HC01

{
preproc
	errmsg("%v is selected for time use",DEM_NAME(TU_ELG_LN));
}
PROC D00_DWELLING_INTRODUCTION
preproc

	savepartial();

	$ = 1;  // prefill continue

PROC HC15


if HC15 > HC14 then //Number of Rooms Checking
		errmsg("The number of sleeping rooms (%d) cannot be more than the total numbers of rooms (%d)", $, HC14)
		select("Reenter number of sleeping rooms", HC15,
			   "Reenter number of Rooms", HC14);
elseif HC15 > 20 then //Number of Rooms Checking
		warning("Please confirm that the number of sleeping rooms is correct (%d)", $)
		select("Reenter number of sleeping rooms", HC15,
			   "Continue", continue);
endif;



PROC HC16
	if $ in 98:99 then
		skip to HC17;
	endif;
PROC HC17
{
if $ <> 1 then
  skip to HC19;
endif;
}
PROC HC39
if $ = 2 then
skip to HC42
endif
PROC HC42
if $ = 2 then
skip to LH_LIVELIHOOD_INTRODUCTION
endif
PROC HC50
if HC42 = 1 & (HC43 = 0 & HC44 = 0 & HC45 = 0 & HC46 = 0 & HC47 = 0 & HC48 = 0 & HC49 = 0 & HC50 = 0) then
  errmsg (0101);
  reenter;  
endif;
PROC HC51


PROC LH_LIVELIHOOD_INTRODUCTION
preproc

	savepartial();

	$ = 1;  // prefill continue
PROC LH1
 
 

postproc

	if pos("A",$)<0 or pos("B",$)<0 or pos("C",$)<0 or pos("D",$)<0 or pos("E",$)<0 or pos("F",$)<0 or pos("G",$)<0 or pos("H",$)<0 or pos("I",$)<0 or pos("J",$)<0 or pos("K",$)<0 or pos("L",$)<0 then
		errmsg("Atleast one option should be checked");
		reenter;
	endif;
	
	if length(strip(LH1))>1 and pos("K",$)>0 then
	errmsg("Invalid combination with none");
	Reenter;
	endif;




PROC LH2

preproc



		ask if pos("L",LH1)>0;

postproc

	if $ = "" then
		errmsg("Specify cannot be blank");
		reenter;
	endif;
PROC LH3

preproc

	if length(strip(LH1))=1 then
		$ = LH1;
	endif;

	ask if length(strip(LH1))>1 and pos("K",LH1)=0;
	
	
		string m = "ABCDEFGHIJL";
		valueset string n;
		do varying numeric counter = 1 while counter <= length(m)
			//errmsg("counter is %d",counter);
			//errmsg("Responce is %s",m[counter:1]);
			if pos(m[counter:1],LH1)>0 then

				n.add(getlabel(LH1,m[counter:1]),m[counter:1]);
				//errmsg("label is %s",getlabel(DEM_31,m[counter:1]));
			endif;
		enddo;
		setvalueset(LH3,n);
		

PROC LH4


preproc



		ask if pos("L",LH3)>0;

postproc

	if $ = "" then
		errmsg("Specify cannot be blank");
		reenter;
	endif;
PROC WS1

PROC WS2
{
if $ in 11,12 then
 skip to WS4
//elseif $ in 61,71 then
//  skip to WS4 
endif;
}
PROC WS3
{preproc
  if addmode then
    savepartial();
  endif;


postproc
  if $ in 11,12 then
    skip to WS5
  //elseif $ in 61,71 then
   //  skip to WS3
  //elseif $ in 13:51,81,96,99 then
   //	 skip to WS5
  endif;
}
PROC WS4

preproc
	ask if WS3 <> 95;
PROC WS5

preproc
	ask if WS3 <> 95;

{

onfocus
numeric j;
  clean_labels();
  j = 0;
  do i = 1 while i <= totocc(HM_REC000); 
      codes(j)  = i;
      labels(j) = DEM_NAME(i);
      j = j + 1;
  enddo;
  j=j+1;
  codes(j)  = 99;
  labels(j) = "No response";
  SetValueSet( @GetSymbol(), codes, labels );
}


{
PROC WS4
if $ = 0 then
 skip to WS11
endif;  
}

{
PROC DEM_END

preproc $ = 1;

	// Calculate the total number of eligible members (at or above the minimum working age) and update GHNELIGIBLE variable
	GHNELIGIBLE = count(DEM_06 where DEM_06 >= NWAP);

postproc

	// End module when information for all members is collected
	if PPNO = totocc(HMPPNO000) then
		endgroup;
	endif;

}

{

PROC DEM_MORE

preproc

	// Ask when input for previous person was blank. Except for first person
	if HMPPNO > 1 then
		ask if DEM_OTH(HMPPNO-1) = notappl;
		endif;

}

{
PROC DEM_OTH

preproc ask if DEM_MORE = 2 or DEM_MORE = notappl;

postproc

	// End module when no more persons are reported to live in this household
	if $ = 2 then
		endgroup;
	endif;
}









{
if $ <> 1 then
  skip to HC17;
endif;
}



{
PROC HC04



postproc

	if pos("A",$)<0 or pos("B",$)<0 or pos("C",$)<0 or pos("D",$)<0 or pos("E",$)<0 or pos("F",$)<0 or pos("G",$)<0 or pos("H",$)<0 or pos("I",$)<0 or pos("J",$)<0 or pos("K",$)<0 or pos("L",$)<0 then
		errmsg("Atleast one option should be checked");
		reenter;
	endif;
	
	if length(strip(HC04))>1 and pos("K",$)>0 then
	errmsg("Invalid combination with none");
	Reenter;
	endif;
}

{

PROC HC05




preproc



		ask if pos("L",HC04)>0;

postproc

	if $ = "" then
		errmsg("Specify cannot be blank");
		reenter;
	endif;
PROC HC06




preproc

	if length(strip(HC04))=1 then
		$ = HC04;
	endif;

	ask if length(strip(HC04))>1 and pos("K",HC04)=0;
	
	
		string m = "ABCDEFGHIJL";
		valueset string n;
		do varying numeric counter = 1 while counter <= length(m)
			//errmsg("counter is %d",counter);
			//errmsg("Responce is %s",m[counter:1]);
			if pos(m[counter:1],HC04)>0 then

				n.add(getlabel(HC04,m[counter:1]),m[counter:1]);
				//errmsg("label is %s",getlabel(DEM_31,m[counter:1]));
			endif;
		enddo;
		setvalueset(HC06,n);
		


PROC HC07

preproc



		ask if pos("L",HC06)>0;

postproc

	if $ = "" then
		errmsg("Specify cannot be blank");
		reenter;
	endif;}
	{
PROC HOUSEHOLDLFS_FF
}

PROC E00_EMIGRATION_INTRODUCTION

preproc

	savepartial();

	$ = 1;  // prefill continue

PROC E01_EMIGRATION
	if $ = 2 then
		skip to XE07;
	endif;

PROC E_KEEP_ROW

preproc

	// Initialize when entering row for 1st time
	if visualvalue(E_KEEP_ROW) = notappl then
		E_KEEP_ROW = 1;
		noinput;
	endif;

onfocus

	// once a row is deleted, it can't be modified
	if visualvalue(E_KEEP_ROW) = 2 then
		setproperty(E_KEEP_ROW,"Protected","Yes");
	else
		setproperty(E_KEEP_ROW,"Protected","No");
	endif;

postproc

	ShowHideEmigration();

	if E_KEEP_ROW = 2 then // the row is deleted
		skip to E_MORE_ROWS;
	endif;


PROC XE01
	if $ = "" then
		errmsg("Please provide the name of the emigrant.");
		reenter;
	endif;

	ShowHideEmigration();

PROC XE05


	numeric calculatedYearOfBirth = SurveyYear - DEM_06(curocc());
	
	
	if $ < calculatedYearOfBirth then
		errmsg("The year of departure (%d) is inconsistent with age (%d) and year of birth (%d) of %d ",$, XE05, calculatedYearOfBirth, XE04)
		select("Reenter year of departure", $,
			   "Reenter emigrant's age", XE03);
	endif;

PROC XE06


	// TODO: are these checks really needed? what is special about the codes 1-4?
	if $ in 1:4 then

		if XE03 in 5:12 then
			warning("Confirm that emigrant aged (%d) is involved in %s", XE03, getlabel($, $))
			select("Reenter age of emigrant", XE03,
				   "Reenter type of activity abroad", $,
				   "Continue", continue);

		elseif XE03 < 5 then
			errmsg("Emigrant aged (%d) cannot be involved in %s", XE03, getlabel($, $))
			select("Reenter age of emigrant ", XE03,
				   "Reenter type of activity abroad", $);

		endif;
		
	elseif $ in 5,8:9 then
	
		if XE03 in 0:10 then
			errmsg("Emigrant aged (%d) is involved in %s", XE03, getlabel($, $))
			select("Reenter age of emigrant ", XE03,
				   "Reenter type of activity abroad", $);
		endif;

	endif;


PROC E_MORE_ROWS

preproc

	savepartial();

	// if there are already more rows defined, this value has to be 1...
	if curocc() < maxocc(EMIGRATION_ROSTER) and XE01(curocc() + 1) <> "" then
		E_MORE_ROWS = 1;
		noinput;
	endif;

onfocus

	// and then cannot be modified
	if curocc() < maxocc(EMIGRATION_ROSTER) and XE01(curocc() + 1) <> "" then
		setproperty(E_MORE_ROWS,"Protected","Yes");
	else
		setproperty(E_MORE_ROWS,"Protected","No");
	endif;

postproc

	if E_MORE_ROWS = 2 then

		if count(E_KEEP_ROW = 1) = 0 then
			errmsg("No emigration rows were entered.")
			select("Reenter whether or not there were any emigrants",E01_EMIGRATION,
				   "Add an emigration row",E_MORE_ROWS);

		else
			endgroup;

		endif;

	endif;


PROC XE08

preproc

	ask if XE07 = 1;

PROC XE10

preproc

	ask if XE09 = 1;

PROC HH_CONCLUSION

preproc

	// clear out any response so that they always have to manually accept the case
	HH_CONCLUSION = notappl;
	//household_reviews();

onfocus

	//if HH_TYPE = 1 then
	//	setvalueset(HH_CONCLUSION,HH_REGULAR_CONCLUSION_VS);
	///else
		setvalueset(HH_CONCLUSION,HH_REGULAR_CONCLUSION_VS);
	//endif;

postproc

	if HH_CONCLUSION = 1 then
		// the program will close after this field
		HH_END_INTERVIEW_TIME = timestamp();

	elseif HH_CONCLUSION = 2 then
		reenter DEM_STR;

	elseif HH_CONCLUSION = 3 then
		reenter D00_DWELLING_INTRODUCTION;

	elseif HH_CONCLUSION = 4 then
		reenter E00_EMIGRATION_INTRODUCTION;

	endif;
